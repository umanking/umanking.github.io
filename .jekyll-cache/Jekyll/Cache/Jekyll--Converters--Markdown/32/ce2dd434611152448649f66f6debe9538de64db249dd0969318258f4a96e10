I"<h1 id="실무에서-필요한jpa---다양한-연관관계매핑4">실무에서 필요한JPA - 다양한 연관관계매핑(4)</h1>

<h2 id="들어가며">들어가며</h2>

<p>엔티티의 연관관계를 매핑할 때는 다음 3가지를 고려해야 한다.</p>

<ul>
  <li>다중성: 다대일, 일대다 등등</li>
  <li>단방향, 양방향: 객체관계에서 한쪽만 참조할지, 양쪽을 참조할지</li>
  <li>연관관계의 주인: JPA는 두 객체 연관관계 중 하나를 정해서 데이터 베이스 외래키를 관리하는데 이것을 연관관계의 주인이라 한다.</li>
</ul>

<h2 id="다대일">다대일</h2>

<h3 id="다대일-단방향n1">다대일 단방향[N:1]</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{...}</span>
</code></pre></div></div>

<h3 id="다대일-양방향1n-n1">다대일 양방향[1:N, N:1]</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
    
    <span class="c1">// 무한 루프에 빠지지 않도록 체크</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="k">this</span><span class="o">)){</span>
 	     <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
  
  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"team"</span><span class="o">)</span> <span class="c1">// 반대편이 연관관계의 주인이다.</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">members</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="c1">// 무한 루프에 빠지지 않도록 체크</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">){</span>
	      <span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>양방향 연관관계는 항상 서로 참조해야 한다.
    <ul>
      <li>항상 서로 참조하기 위해서는 연관관계 편의 메서드를 작성하는 것이 좋은데, 편의 메서드는 어느 한 곳에만 작성하거나, 양쪽다 작성할 수 있다. 양쪽에 다 작성하면 무한루프에 빠지지 않도록 주의한다.</li>
    </ul>
  </li>
</ul>

<h2 id="일대다">일대다❌</h2>

<h3 id="일대다-단방향1n">일대다 단방향[1:N]</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
  <span class="nd">@OneToMany</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span> <span class="c1">// MEMBER 테이블의 TEAM_ID(FK)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{...}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>일대다 단방향 관계는 약간 특이한데, 보통 자신이 매핑한 테이블의 외래키를 관리하는데, 이매핑은 반대쪽 테이블에 있는 외래키를 관리한다. 그럴 수 밖에 없는 것이 일대다 관계에서 외래키는 항상 다쪽 테이블에 있다. 하지만 다쪽인 Member엔티티에는 외래키를 매핑할 수 있는 참조 필드가 없다. 대신에 반대쪽인 Team 엔티티에만 참조 필드인 members가 있다. 따라서 반대편 테이블의 외래키를 관리하는 특이한 모습이 나타난다.</p>
  </li>
  <li>
    <p>일대다 단방향 관계를 매핑할때는 @JoinColumn을 명시해야 한다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인테이블(JoinTable) 전략을 기본으로 사용해서 매핑한다.</p>
  </li>
  <li>
    <p>일대다 단방향 매핑의 단점</p>
    <ul>
      <li>매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점. 본인 테이블에 외래키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT SQL 한번으로 끝낼 수 있지만, 다른 테이블에 외래키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 한다.</li>
      <li>일대다 단방향 매핑의 단점을 알아보자.</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSave</span><span class="o">(){</span>
  
	<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
  <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>
  
  <span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">);</span>
  <span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
  <span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
  
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">//insert - member1</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span> <span class="c1">//insert - member2</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>   <span class="c1">//insert - team1, update - member1.fk, update- member2.fk</span>
  
  <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Member엔티티를 저장할때 MEMBER 테이블의 TEAM_ID 외래키에 아무값도 저장되지 않는다. 대신 Team 엔티티를 저장할때, Team.members 참조 값을 확인해서 회원 테이블에 있는 TEAM_ID 외래키를 업데이트 하는 쿼리가 나간다.</p>

<ul>
  <li><strong>일대다 단방향 매핑보다는 <code class="language-plaintext highlighter-rouge">다대일 양방향</code> 매핑을 사용하자. 💯</strong>
    <ul>
      <li>일대다 단방향 매핑을 사용하면 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래키를 관리해야한다. 성능의 문제도 있지만, 관리도 부담스럽다.</li>
      <li>좋은 방법은 일대다 단방향 대신에 다대일 양방향 매핑을 사용하는것이다.</li>
      <li>다대일 양방향은 관리해야 하는 외래 키가 본인 테이블에 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="일대다-양방향1n-n1">일대다 양방향[1:N, N:1]</h3>

<ul>
  <li>일대다 양방향 매핑은 존재하지 않는다. 대신 다대일 양방향 매핑을 사용해야 한다.</li>
  <li>더 정확히 말해, 양방향 매핑에서 @OneToMany는 연관관계의 주인이 될 수 없다. RDB특성상 일대다, 다대일 관계는 항상 다 쪽에 외래키가 있다.</li>
  <li>따라서 @OneToMany, @ManyToOne 둘중에 연관관계의 주인은 항상 다 쪽인 @ManyToOne을 사용한 곳이다. 이런이유로 @ManyToOne에는 mappedBy 속성이 없다.</li>
  <li>그렇다고 완전히 불가능 한 것은 아니다. 일대다 단방향 매핑 반대편에 같은 외래키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 하나 추가하면된다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>

  <span class="nd">@OneToMany</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">,</span> <span class="n">insertable</span><span class="o">=</span><span class="kc">false</span><span class="o">,</span> <span class="n">updatable</span><span class="o">=</span><span class="kc">false</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>일대다 단방향 매핑 반대편에 다대일 단방향 매핑을 추가했다. 이때 일대다 단방향 매핑과 같은 TEAM_ID 외래 키 컬럼을 매핑했다. 이렇게 되면 둘다 같은 키를 관리하므로 문제가 발생한다. 따라서 반대편인 다대일 쪽은 insertable, updatable을 false로 설정해서 읽기만 가능하게 했다.</li>
  <li>결론: 될 수 있으면 <code class="language-plaintext highlighter-rouge">다대일 양방향</code>을 사용하자!</li>
</ul>

<h2 id="일대일11">일대일[1:1]</h2>

<ul>
  <li>일대일 관계는 양쪽이 서로 하나의 관계만 가진다.</li>
  <li>일대일 관계는 주테이블이나 대상 테이블 둘 중 어느곳이나 외래키를 가질 수 있다.</li>
  <li>따라서 일대일 관계는 누가 외래키를 가질지 선택해야 한다.</li>
</ul>

<h3 id="주테이블에-외래키">주테이블에 외래키</h3>

<ul>
  <li>주로 객체지향 개발자들이 선호</li>
</ul>

<h4 id="단방향">단방향</h4>

<ul>
  <li>회원(<code class="language-plaintext highlighter-rouge">주테이블</code>)과 사물함(<code class="language-plaintext highlighter-rouge">대상 테이블</code>) 일대일</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주테이블에 외래키가 존재하는 경우</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@OneToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span> <span class="o">{...}</span>
</code></pre></div></div>

<h4 id="양방향">양방향</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@OneToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span> <span class="o">{</span>
  <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"locker"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>양방향이므로 연관관계 주인을 정해야 한다. MEMBER 테이블이 외래키를 가지고 있으므로 Member엔티티에 있는 <strong><u>Member.locker가 연관관계의 주인이다.</u></strong> 따라서 반대 매핑인 사물함의 Locker.member는 mappedBy를 선언해서 반대편이 연관관계의 주인임을 나타낸다.</p>

<h3 id="대상-테이블에-외래키">대상 테이블에 외래키</h3>

<p>이번에는 대상 테이블에 외래키가 있는 일대일 관계를 보자.</p>

<h4 id="단방향-1">단방향</h4>

<ul>
  <li>대상 테이블에 외래키가 있는 단방향 관계는 JPA는 지원하지 않는다. ❌</li>
</ul>

<h4 id="양방향-1">양방향</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일대일 대상 테이블에 외래키, 양방향 예제코드 </span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span> <span class="o">{</span>
  <span class="nd">@OneToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 이렇게 양방향으로 매핑한다.</p>

<h2 id="다대다nn">다대다[N:N]</h2>

<ul>
  <li>관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.</li>
  <li>다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용한다.</li>
  <li>회원과 상품 테이블인경우
    <ul>
      <li>MEMBER, MEMBER_PRODUCT, PRODUCT 테이블과 같이 풀어낼수 있다.</li>
      <li>하지만 객체는 테이블과 다르게 객체 2개로 다대다 관계를 만들 수 있다.</li>
    </ul>
  </li>
</ul>

<h3 id="다대다단방향">다대다:단방향</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@ManyToMany</span>
  <span class="nd">@JoinTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_PRODUCT"</span><span class="o">,</span> 
            <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER_ID"</span><span class="o">),</span> 
            <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
            <span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{...}</span>
</code></pre></div></div>

<ul>
  <li>다대다 관계를 저장하는 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
  <span class="nc">Proudct</span> <span class="n">productA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">();</span>
  <span class="n">productA</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"productA"</span><span class="o">);</span>
  <span class="n">productA</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"상품A"</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">productA</span><span class="o">);</span>
  
  <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
  <span class="n">member1</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
  <span class="n">member1</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">);</span>
  <span class="n">member1</span><span class="o">.</span><span class="na">getProducts</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">productA</span><span class="o">);</span> <span class="c1">// 연관관계 설정</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이 코드를 실행하면 다음과 같이 SQL이 실행된다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">PRODUCT</span> <span class="p">...</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">MEMBER</span> <span class="p">...</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">MEMBER_PRODUCT</span> <span class="p">...</span> <span class="o">//</span> <span class="err">연결테이블도</span> <span class="err">같이</span> <span class="err">저장이</span> <span class="err">된다</span><span class="p">.</span>
</code></pre></div></div>

<p>저장후에 member.getProduct()를 호출하게 되면 다음 SQL이 실행된다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">MEMBER_PRODUCT</span> <span class="n">MP</span> 
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">PRODUCT</span> <span class="n">P</span> <span class="k">ON</span> <span class="n">MP</span><span class="p">.</span><span class="n">PRODUCT_ID</span> <span class="o">=</span> <span class="n">P</span><span class="p">.</span><span class="n">PRODUCT_ID</span>
<span class="k">WHERE</span> <span class="n">MP</span><span class="p">.</span><span class="n">MEMBER_ID</span> <span class="o">=?</span>
</code></pre></div></div>

<p>연결테이블인 MEMBER_PRODUCT와 상품테이블을 조인해서 연관된 상품을 조회한다.</p>

<h3 id="다대다양방향">다대다:양방향</h3>

<ul>
  <li>다대다 매핑이므로 역방향도 @ManyToMany를 사용한다. 양쪽 원하는 곳에 mappedBy로 연관관계의 주인을 지정한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  
  <span class="nd">@ManyToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"products"</span><span class="o">)</span> <span class="c1">// 역방향 추가</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>연관관계 편의 메서드를 추가해서 관리하는 것이 편리하다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="o">...</span>
    
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addProduct</span><span class="o">(</span><span class="nc">Product</span> <span class="n">product</span><span class="o">){</span>
    <span class="n">products</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
    <span class="n">product</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<h3 id="다대다매핑의-한계와-극복-연결-엔티티-사용">다대다:매핑의 한계와 극복, 연결 엔티티 사용❌</h3>

<ul>
  <li>@ManyToMany를 사용하면 연결 테이블을 자동으로 처리해주므로 편리하다. 하지만 실무에서 사용하기에는 한계가 있다.</li>
  <li>연결 테이블에 단순히 주문한 회원 아이디, 상품 아이디만 담고 끝나지 않는다. 보통 연결테이블에 주문 수량, 주문한 날짜와 같은 컬럼이 더 필요하다.</li>
  <li>여기서는 회원상품(MemberProduct)엔티티를 추가했다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  
  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberProduct</span><span class="o">&gt;</span> <span class="n">memberProducts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>상품코드를 보면, <code class="language-plaintext highlighter-rouge">상품 엔티티</code>에서 <code class="language-plaintext highlighter-rouge">회원상품 엔티티</code>로 객체그래프 탐색 기능이 필요하지 않다고 판단해서 연관관계를 만들지 않았다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">MemberProductId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberProduct</span> <span class="o">{</span>
  
  <span class="nd">@Id</span>
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColum</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Membmer</span> <span class="n">member</span><span class="o">;</span> <span class="c1">// MemberProductId.member와 연결 </span>
  
  <span class="nd">@Id</span>
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColum</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span> <span class="c1">// MemberProductId.product와 연결 </span>
  
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">orderAmount</span><span class="o">;</span>
  
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//회원 상품 식별자 클래스 </span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberProductId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">member</span><span class="o">;</span> <span class="c1">//MemberProduct.member와 연결</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">product</span><span class="o">;</span> <span class="c1">//MemberProduct.product와 연결</span>
  
  <span class="c1">//hashCode and equals</span>
  
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>회원상품 엔티티를 보면 기본 키를 매핑하는 @Id와 외래키를 매핑하는 @JoinColumn을 동시에 사용해서 기본키 + 외래키를 한번에 매핑했다.</li>
  <li>@IdClass를 사용해서 복합 기본키를 매핑했다.</li>
  <li>복합 기본 키
    <ul>
      <li>회원상품 엔티티는 기본키가 MEMBER_ID와 PRODUCT_ID로 이루진 복합 기본키다.</li>
      <li>JPA는 복합키를 사용하려면 별도의 식별자 클래스를 만들어야 한다. 그리고 엔티티에 @IdClass를 사용해서 식별자 클래스를 지정하면된다.</li>
      <li>복합키를 위한 식별자 클래스는 다음과 같은 특징이 있다.
        <ul>
          <li>복합키는 별도의 식별자 클래스로 만들어야 한다,</li>
          <li>Serializable을 구현해야 한다.</li>
          <li>equals와 hashCode를 구현해야 한다.</li>
          <li>기본 생성자가 있어야한다.</li>
          <li>식별자 클래스가 public이어야한다.</li>
          <li>@IdClass를 사용하는 방법외에 @EmbeddedId를 사용하는 방법도 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>식별관계
    <ul>
      <li>회원상품은 회원과 상품의 기본키를 받아서 자신의 기본 키로 사용한다. 이렇게 부모 테이블의 기본키를 받아서 자신의 기본키 + 외래키로 사용하는 것을 DB용어로 식별관계라고 한다.</li>
    </ul>
  </li>
  <li>저장하는 예제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
  
  <span class="c1">// 회원저장</span>
  <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
  <span class="n">member1</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
  <span class="n">member1</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

  <span class="c1">// 상품저장</span>
  <span class="nc">Proudct</span> <span class="n">productA</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">();</span>
  <span class="n">productA</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"productA"</span><span class="o">);</span>
  <span class="n">productA</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"상품A"</span><span class="o">);</span>
  <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">productA</span><span class="o">);</span>
  
  <span class="c1">// 회원상품 저장 </span>
  <span class="nc">MemberProduct</span> <span class="n">memberProduct</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberProduct</span><span class="o">();</span>
  <span class="n">memberProduct</span><span class="o">.</span><span class="na">setMember</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> 	<span class="c1">//주문 회원 - 연관관계 설정</span>
  <span class="n">memberProduct</span><span class="o">.</span><span class="na">setProduct</span><span class="o">(</span><span class="n">productA</span><span class="o">);</span>	<span class="c1">//주문 상품 - 연관관계 설정</span>
  <span class="n">memberProduct</span><span class="o">.</span><span class="na">setOrderAmount</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> 		<span class="c1">//주문 수량</span>
  
 	<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberProduct</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>조회 코드</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">find</span><span class="o">(){</span>
  <span class="c1">// 기본키 값 생성</span>
  <span class="nc">MemberProductId</span> <span class="n">memberProductId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberProductId</span><span class="o">();</span>
  <span class="n">memberProductId</span><span class="o">.</span><span class="na">setMember</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
  <span class="n">memberProductId</span><span class="o">.</span><span class="na">setProduct</span><span class="o">(</span><span class="s">"productA"</span><span class="o">);</span>
  
  <span class="nc">MemberProduct</span> <span class="n">memberProduct</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">MemberProduct</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberProductId</span><span class="o">);</span>
  
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberProduct</span><span class="o">.</span><span class="na">getMember</span><span class="o">();</span>
  <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">memberProduct</span><span class="o">.</span><span class="na">getProduct</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>복합키는 항상 식별자 클래스를 만들어야 한다. em.find()를 보면 생성한 식별자 클래스로 엔티티르 조회한다.</li>
  <li>다음으로 복합키를 사용하지 않고 간단히 다대다 관계를 구성하는 방법을 알아보자.</li>
</ul>

<h3 id="다대다새로운-기본-키-사용">다대다:새로운 기본 키 사용</h3>

<ul>
  <li>추천하는 기본 키 생성전략은 데이터베이스에서 자동으로 생성해주는 대리 키를 Long값으로 사용하는 것이다. 이것의 장점은 간편하고 거의 영구히 쓸수 있으며 비즈니스에 의존하지 않는다. 그리고 ORM 매핑시 복합키를 만들지 않아도 되므로 간단히 매핑을 완성할 수 있다.</li>
  <li>
    <p>이번에는 연결테이블에 새롱누 기본 키를 사용해보자. 회원상품(MemberProduct) 보다는 더 적절한 이름인 주문(Order)을 사용한다.</p>
  </li>
  <li>ORDER_ID라는 새로운 기본 키를 하나 만들고, MEMBER_ID, PRODUCT_ID컬럼은 외래키로 사용한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDRE_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
  
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>
  
  <span class="nd">@ManyToOne</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span>
  
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">orderAmount</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>조회하는 코드</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">find</span><span class="o">(){</span>
  <span class="nc">Long</span> <span class="n">orderId</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
  <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderId</span><span class="o">);</span>
  
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getMember</span><span class="o">();</span>
  <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getProduct</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>식별자 클래스를 사용하지 않아서 코드가 한결 단순해졌다.</p>

<h3 id="다대다-연관관계-정리">다대다 연관관계 정리</h3>

<ul>
  <li>다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 연결테이블을 만들 때 식별자를 어떻게 구성할지 선택해야 한다.
    <ul>
      <li>식별 관계: 받아온 식별자를 기본키 + 외래키로 사용한다.</li>
      <li>비식별 관계: 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다.👍</li>
    </ul>
  </li>
  <li>객체 입장에서 2번처럼 비식별관계를 사용하는 것이 복합키를 위한 식별자 클래스를 만들지 않아도 되므로 단순하고 편리하게 ORM매핑을 사용할 수 있따. 이런 이유로 식별관계보다는 <u>**비식별 관계를 추천한다.**</u></li>
</ul>
:ET