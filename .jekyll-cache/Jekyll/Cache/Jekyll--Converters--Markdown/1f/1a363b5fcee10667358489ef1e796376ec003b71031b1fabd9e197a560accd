I"-<blockquote>
  <p>본 글은, <a href="http://www.yes24.com/Product/Goods/19040233">자바 ORM 표준 JPA 프로그래밍(김영한님)</a> 책을 요약 정리한 포스팅입니다.</p>
</blockquote>

<ul>
  <li><a href="/2021/06/19/jpa-summary-persistence-context">실무에서 필요한JPA - 영속성 관리(1)</a></li>
  <li><a href="/2021/06/19/jpa-summary-entity-mapping">실무에서 필요한JPA - 엔티티 매핑(2)</a></li>
  <li><a href="/2021/06/19/jpa-summary-basic-releation-mapping">실무에서 필요한JPA - 연관관계 매핑(기초)(3)</a></li>
  <li><a href="/2021/06/19/jpa-summary-advanced-releation-mapping">실무에서 필요한JPA - 다양한 연관관계매핑(4)</a></li>
  <li><a href="/2021/06/20/jpa-summary-proxy">실무에서 필요한JPA - 프록시와 연관관계(5)</a></li>
  <li><a href="/2021/06/20/jpa-summary-value-type">실무에서 필요한JPA - 값타입(6)</a></li>
  <li>실무에서 필요한JPA - 객체지향 쿼리(7)</li>
  <li>실무에서 필요한JPA - 스프링 데이터 JPA(8)</li>
  <li>실무에서 필요한JPA - 컬렉션과 부가기능(9)</li>
  <li>실무에서 필요한JPA - 고급주제와 성능 최적화(10)</li>
  <li>실무에서 필요한JPA - 트랜잭션과 락 2차 캐시(11)</li>
</ul>

<h1 id="실무에서-필요한jpa---영속성-관리1">실무에서 필요한JPA - 영속성 관리(1)</h1>

<h2 id="학습목표">학습목표</h2>

<ul>
  <li>EntityMangerFacotry와 EntityManager의 관계를 이해한다.</li>
  <li>PersistenceContext(영속성 컨텍스트)의 특징을 이해하고, CRUD에서 어떻게 동작하는지를 이해한다.</li>
  <li>영속성 컨텍스트가 관리하는 엔티티의 생명주기를 이해한다.</li>
  <li>Flush에 대해서 알아본다.</li>
  <li>준영속 상태의 특징을 이해한다.</li>
</ul>

<h2 id="엔티티-매니저-팩토리와-엔티티-매니저">엔티티 매니저 팩토리와 엔티티 매니저</h2>

<ul>
  <li>EntityManagerFactory는 EntityManager를 만드는 공장인데, 공장을 만드는 비용은 상당히 크다. 따라서 싱글턴으로 만들어서 웹 애플리케이션에서 공유하도록 설계되어있다.</li>
  <li>EntityMangaer는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. (Lazy). 트랜잭션을 시작할때 커넥션을 획득한다.</li>
  <li>Hibernate를 포함한 JPA 구현체들은 EntityManagerFactory를 생성할 때 커넥션 풀도 만든다.</li>
</ul>

<h2 id="영속성-컨텍스트persistence-context">영속성 컨텍스트(Persistence Context)</h2>

<ul>
  <li>JPA를 이해하는데 가장 중요한 핵심</li>
  <li>엔티티를 영구히 저장하는 환경정도라고 이해하면 된다.</li>
  <li>EntityManager를 생성할때 영속성 컨텍스트가 만들어진다.</li>
  <li>EntityManger를 통해서 영속성 컨텍스트에 접근하거나 관리할 수 있다.</li>
</ul>

<h2 id="엔티티-생명주기">엔티티 생명주기</h2>

<ul>
  <li>비영속 (new/transient): 전혀 관계가 없는 상태</li>
  <li>영속(managed): 영속성 컨텍스트에 저장된 상태</li>
  <li>준영속(detached): 저장되었다가 분리된 상태</li>
  <li>삭제(remove): 삭제된 상태</li>
</ul>

<p><img src="https://media.vlpt.us/post-images/conatuseus/3861eed0-d482-11e9-9b0f-dd1a4f570095/image.png" style="zoom:50%;" />
<em>출처: 자바 JPA 프로그래밍(김영한)</em></p>

<h2 id="영속성-컨텍스트의-특징">영속성 컨텍스트의 특징</h2>

<ul>
  <li>영속성 컨텍스트는 엔티티를 식별자 값(@Id로 매핑한 값) 으로 구분한다. 영속상태는 식별자 값이 반드시 있어야 한다. 없으면 예외가 발생한다.</li>
  <li>영속성 컨텍스트와 데이터 베이스 저장. JPA는 보통 트랜잭션을 커밋하는 순간, 영속성컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다(Flush)</li>
  <li>영속성 컨텍스트의 장점
    <ul>
      <li>1차 캐시</li>
      <li>동일성 보장</li>
      <li>트랙잭션을 지원하는 쓰기 지연</li>
      <li>변경 감지</li>
      <li>지연 로딩</li>
    </ul>
  </li>
</ul>

<h3 id="엔티티-조회">엔티티 조회</h3>

<ul>
  <li>em.find(Member.class, “member1”)를 호출하고, 1차 캐시를 먼저 찾는다.</li>
  <li>없으면 데이터베이스에서 조회하고, 조회한 데이터를 1차캐시에 저장한다.</li>
  <li>이후에 member1로 조회하게되면 영속성 컨텍스트에서 식별자를 통해서 해당 엔티티를 반환한다. (캐쉬가 동작하는 원리)</li>
</ul>

<h3 id="엔티티-등록">엔티티 등록</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">em.persist(memberA)</code> 까지는 INSERT SQL문을 데이터베이스에 보내지 않는다. <code class="language-plaintext highlighter-rouge">transaciton.commit()</code> 커밋하는 순간에 보낸다. → 성능최적화에서 다룬다.✅
    <ul>
      <li>EntityManager는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL을 모아둔다. 그리고 트랜잭션을 커밋할때 모아둔 쿼리를 데이터베이스에 보내는데, 이를 트랜잭션을 지원하는  <code class="language-plaintext highlighter-rouge">쓰기 지연</code> 이라 한다.</li>
    </ul>
  </li>
  <li>트랜잭션을 커밋하면 EntityManger는 우선 영속성 컨텍스트를 Flush한다. <strong>Flush는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업이다.</strong></li>
</ul>

<h3 id="엔티티-수정변경-감지">엔티티 수정(변경 감지)</h3>

<ul>
  <li>JPA로 엔티티를 수정할 때는 엔티티를 조회해서, 데이터만 변경하면 된다.이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 <code class="language-plaintext highlighter-rouge">변경감지</code>(Dirty checking)</li>
  <li>JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라고 한다. Flush 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.</li>
  <li>변경감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.</li>
  <li>JPA의 기본전략은 엔티티의 모든 필드를 업데이트 한다.
    <ul>
      <li>모든 필드를 사용하면, 데이터 전송량이 증가하는 단점이 있지만 다음과 같은 장점으로 인해 모든 필드를 업데이트 한다.
        <ul>
          <li>모든 필드를 사용하면 수정 쿼리는 항상 같다. 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용 가능하다.</li>
          <li>데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 파싱된 쿼리를 재사용 할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>만약에, 필드가 너무 많거나 저장되는 내용이 너무 크면 <code class="language-plaintext highlighter-rouge">수정된</code> 데이터만 사용해서 동적으로 UPDATE SQL를 생성하는 전략을 선택하면 된다. 이때는 하이버네이트 확장 기능을 사용해야 한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@org</span><span class="o">.</span><span class="na">hibernate</span><span class="o">.</span><span class="na">annotations</span><span class="o">.</span><span class="na">DynamicUpdate</span>
<span class="nd">@Table</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{...}</span>
</code></pre></div></div>

<h3 id="엔티티-삭제">엔티티 삭제</h3>

<ul>
  <li>엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한다. 이후 트랜잭션 커밋해서, 플러시를 호출하면 실제 데이터베이스에 삭제 쿼리를 전달한다.</li>
</ul>

<h2 id="플러시flush">플러시(Flush)</h2>

<ul>
  <li>플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.</li>
  <li>영속성 컨텍스트를 플러시 하는 방법
    <ul>
      <li>em.flush()를 직접 호출한다. (거의 사용하지 않는다.)</li>
      <li>트랜잭션 커밋시 플러시가 자동 호출된다. (JPA는 트랜잭션을 커밋할때)</li>
      <li>JPQL쿼리 실행 시 플러시가 자동 호출된다.</li>
    </ul>
  </li>
  <li>플러시 모드 옵션
    <ul>
      <li>javax.persistence.FlushModeType를 사용한다.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">em.setFlusMode(FlushModeType.COMMIT)</code> 직접 설정</li>
          <li>FlushModeType.AUTO: 커밋이나 쿼리를 실행할때 플러시(기본값)</li>
          <li>FlushModeType.COMMIT: 커밋할 때만 플러시</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="준영속">준영속</h2>

<ul>
  <li>영속성 컨텍스트가 관리하는 영속상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태라 한다. 준영속 상태 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.</li>
  <li>준영속 상태로 만드는 방법
    <ul>
      <li>em.detach(entity): 특정 엔티티만 준영속 상태로 전환한다.</li>
      <li>em.clear(): 영속성 컨텍스트를 완전히 초기화한다.</li>
      <li>em.close(): 영속성 컨텍스트를 종료한다.
        <ul>
          <li>1차캐시, 쓰지지연 저장소등이 존재하지 않는다. 종료되었다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>준영속 상태의 특징
    <ul>
      <li>거의 비영속 상태에 가깝다. 영속성 컨텍스트가 제공하는 1차 캐시, 쓰기 지연, 변경감지, 지연로딩 어떠한 기능도 동작하지 않음</li>
      <li>식별자 값을 가지고 있다.</li>
      <li>지연로딩을 할 수 없다.</li>
    </ul>
  </li>
  <li>병합: merge()
    <ul>
      <li>준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="정리">정리</h2>

<ul>
  <li>엔티티 매니저는 엔티티 매니저 팩토리에서 생성한다. J2SE환경에서는 엔티티 매니저를 만들면 그 내부에서 영속성 컨텍스트도 함께 만들어진다.</li>
  <li>영속성 컨텍스는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할을 한다. 덕분에 <code class="language-plaintext highlighter-rouge">1차캐시</code>, <code class="language-plaintext highlighter-rouge">동일성 보장</code> 트랜잭션을 지원하는 <code class="language-plaintext highlighter-rouge">쓰기지연</code>, <code class="language-plaintext highlighter-rouge">변경 감지</code> , <code class="language-plaintext highlighter-rouge">지연로딩</code> 기능을 사용할 수 있다.</li>
  <li>영속성 컨텍스트에 저장한 엔티티는 플러시 시점에 데이터베이스에 반영되는데, 일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트가 플러시 된다.</li>
  <li>영속성 컨텍스트의 관리를 받지 못하는 엔티티를 <code class="language-plaintext highlighter-rouge">준영속 상태</code> 라 하고, 이는 영속성 컨텍스트가 제공하는 1차 캐시, 동일성 보장, 쓰기지연, 변경감지, 지연로딩 같은 기능을 사용할 수 없다.</li>
</ul>
:ET