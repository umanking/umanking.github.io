I"h<h2 id="1-overview">1. Overview</h2>

<p><strong>Spring Boot를 통한 REST API 샘플예제를 통해서, 도메인 객체를 validation 하는 방법을 알아보자.</strong>
<u>기본 전제 조건은, 유저가 넘기는 모든 데이터는 신뢰할수 없다.</u> 그렇기 때문에 모든 데이터를 반드시 검증해야 한다.
대게 validation은 Post요청시, @RequestBody에 담길 객체에 대해서 검증하는게 일반적이다.
<!-- more --></p>
<h2 id="2-user-domain">2. User Domain</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"name is required"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"email is required"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="3-implement-restcontrollor">3. Implement RestControllor</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserController</span> <span class="o">{</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">"/users"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">addUser</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="s">"user is valid"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>POST 요청시, 클라이언트가 넘기는 값들은 기본적으로 신뢰할 수 없다. 그렇기 때문에 validation을 반드시 해야 한다. <code class="language-plaintext highlighter-rouge">@Valid</code> 어노테이션만 붙이면, Spring Boot는 JSR303 구현체(Hibernate Validator)를 사용해서 argument값을 validate를 진행한다.</p>

<h2 id="4-exception-handling">4. Exception Handling</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">BAD_REQUEST</span><span class="o">)</span>
<span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="nf">handleValidationExceptions</span><span class="o">(</span><span class="nc">MethodArgumentNotValidException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">errors</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">ex</span><span class="o">.</span><span class="na">getBindingResult</span><span class="o">().</span><span class="na">getAllErrors</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span>
            <span class="o">(</span><span class="n">error</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">fieldName</span> <span class="o">=</span> <span class="o">((</span><span class="nc">FieldError</span><span class="o">)</span> <span class="n">error</span><span class="o">).</span><span class="na">getField</span><span class="o">();</span>
                <span class="nc">String</span> <span class="n">errorMessage</span> <span class="o">=</span> <span class="n">error</span><span class="o">.</span><span class="na">getDefaultMessage</span><span class="o">();</span>
                <span class="n">errors</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">fieldName</span><span class="o">,</span> <span class="n">errorMessage</span><span class="o">);</span>
            <span class="o">}</span>
    <span class="o">);</span>

    <span class="k">return</span> <span class="n">errors</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@ExceptionHandler</code>를 통해서 <code class="language-plaintext highlighter-rouge">MethodArgumentNotValidException</code>를 핸들링 한다. errors map에 담아서 반환하면, <code class="language-plaintext highlighter-rouge">@RestController</code>의 <code class="language-plaintext highlighter-rouge">@ResponseBody</code>를 통해서 JSON 값으로 리턴된다.</p>

<h2 id="5-test">5. TEST</h2>

<p>PostMan으로 <code class="language-plaintext highlighter-rouge">POST /users</code>의 <code class="language-plaintext highlighter-rouge">name</code>과 <code class="language-plaintext highlighter-rouge">email</code> 필드 없이 빈 Json을 넘기면 다음과 같이 나온다.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"name is required"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"email"</span><span class="p">:</span><span class="w"> </span><span class="s2">"email is required"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="생각해볼-것들">생각해볼 것들</h2>

<ul>
  <li><a href="https://beanvalidation.org/2.0/">https://beanvalidation.org/2.0/</a> - <code class="language-plaintext highlighter-rouge">@NotBlank</code> 외의 Bean validation spec</li>
  <li>단순 field validation은 JSR303을 통해서 간단하게 할 수 있다. 하지만, 비즈니스 로직이 필요한 경우라면?</li>
  <li>POST 요청(도메인 객체)만을 검증하나? 아니면 <strong>RequestParam, @Pathvariable 도 검증해야 하나?</strong> (아시는 분들은 댓글좀)</li>
</ul>
:ET