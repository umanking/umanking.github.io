I",<p>모든 블로그의 github 소스는 <a href="">여기</a> 에서 확인합니다.</p>

<h2 id="학습목표">학습목표</h2>

<ul>
  <li>Bean이란 무엇인가?</li>
  <li>Bean의 라이프 사이클</li>
  <li>스프링에서 Bean을 등록하는 방법</li>
  <li>스프링에서 Bean 전처리 / 후처리 하는 방법</li>
</ul>

<h2 id="bean-이란">Bean 이란?</h2>

<p>빈(Bean)이란 스프링이 생명주기를 관리하는 객체이다. 왜 Beans라는 이름을 붙였을까?</p>

<p>개발자가 빈의 scope를 지정할 수 있다. 따로 <code class="language-plaintext highlighter-rouge">@Scope()</code> 로 지정해주지 않는다면 기본(default)은 singleton이고 이외에도 다음과 같이 다양한 스코프가 존재한다.</p>

<ul>
  <li>singleton: Spring이 기동했을때, 오로지 하나의 객체로만 존재한다.</li>
  <li>prototype: 매요청마다 객체가 새로 생성이 된다.</li>
  <li>request:</li>
  <li>session:</li>
</ul>

<blockquote>
  <p>스프링은 흔히 IoC/DI Container라고도 부르는데, 각 Bean들에 대해서 의존관계를 외부(컨테이너)에서 주입해주기 때문에 이렇게 부른다. 빈을 이해하려면, 스프링 프레임워크의 특징도 이해해야 한다.</p>
</blockquote>

<h2 id="bean을-등록하는-방법">Bean을 등록하는 방법</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Bean</code> 어노테이션을 통해서 Bean으로 등록한다.</li>
</ul>

<blockquote>
  <p>note: 빈을 등록하기 위해서는 빈을 등록하는 클래스가 애플리케이션의 @ComponentScan의 대상이 되어야 한다. 이 말인 즉슨, ComponentScan의 대상이 되기 위해서는 클래스 레벨에 <code class="language-plaintext highlighter-rouge">@Component</code> <code class="language-plaintext highlighter-rouge">@Configuration</code> <code class="language-plaintext highlighter-rouge">@Repository</code> <code class="language-plaintext highlighter-rouge">@Service</code> 다음과 같은 어노테이션을 붙이면, 스프링이 해당 컴포넌트들을 스캔할 수 있다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeanConfiguration</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello world"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@Bean</code>을 통해서 Hello world를 리턴하는 hello라는 빈을 등록 했다. <code class="language-plaintext highlighter-rouge">@Bean</code> 프로퍼티로 아무것도 넣지 않으면 빈 네임은 해당 메서드 네임으로 들어간다. 여기에서는 hello라는 빈으로 등록이 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppRunner</span> <span class="kd">implements</span> <span class="nc">ApplicationRunner</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">hello</span><span class="o">;</span>  <span class="c1">// String타입의 hello 빈이 주입된다.</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="nc">ApplicationArguments</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hello</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>빈을 등록했으니, 다음은 <code class="language-plaintext highlighter-rouge">@AutoWired</code>를 통해서 등록된 빈을 사용해보자. 예제 에서는 ApplicationRunner를 구현함으로써 스프링 컨테이너가 동작할 때, <code class="language-plaintext highlighter-rouge">run()</code> 메서드가 실행되는 예제이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello world
</code></pre></div></div>

<p>콘솔창에 다음과 같이 찍힌다.</p>

<h2 id="2-빈-생성-전처리후처리-하는-방법">2. 빈 생성 전처리/후처리 하는 방법</h2>

<ol>
  <li>JSR-250 어노테이션 (@PostConstruct, @PreDestroy … ) 사용</li>
  <li>@Bean의 프로퍼티로 (initMethodName, destroyMethodName) 사용</li>
</ol>

<h3 id="jsr-250-어노테이션-사용">JSR-250 어노테이션 사용</h3>

<p>JSR-250 어노테이션을 사용하면 쉽게 빈을 생성, 폐기 시점을 알 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BarService</span> <span class="o">{</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// BarService 빈 생성 전에 동작</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Post Init bean"</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// BarService 빈 폐기 전에 동작</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Pre Destroy bean"</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>BarService를 <code class="language-plaintext highlighter-rouge">@Service</code>로 등록해주고, 빈의 생성 후, 폐기 전에 맞는 <code class="language-plaintext highlighter-rouge">@PostConstruct</code> 와 <code class="language-plaintext highlighter-rouge">@PreDestroy</code> 를 통해서 하고 싶은 작업을 할 수 있다. 애플리케이션을 실행하고, 종료하게 되면 다음과 같이 나온다. 실행할 때 이미 만들어진 빈들을 등록하기 때문에 따른 코드를 넣지 않아도 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Post Init bean
&gt; 애플리케이션 종료하게 되면
Pre Destroy bean
</code></pre></div></div>

<h3 id="bean-프로퍼티-initmethodname--destroymethodname-를-통한-방법">@Bean 프로퍼티 initMethodName / destroyMethodName 를 통한 방법</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// init logic</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Init Foo"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bar</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cleanup</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// destory logic</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"cleanup Bar"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Foo, Bar 클래스에서 각각 빈의 초기화, 폐기 관련 작업을 할 메소드를 정의한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">initMethod</span> <span class="o">=</span> <span class="s">"init"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Foo</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Foo</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span><span class="o">(</span><span class="n">destroyMethod</span> <span class="o">=</span> <span class="s">"cleanup"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Bar</span> <span class="nf">bar</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Bar</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>빈을 등록하면서 해당 빈의 어트리뷰트에 위에서 작성했던 메서드명을 넘긴다. 인텔리J에는 해당 메서드의 리턴 타입에 따라서 메서드명을 자동으로 띄워준다.</p>

<h3 id="jsr-250-과-bean-프로퍼티를-동시에-사용하면-우선순위는-어떻게-될까">JSR-250 과 @Bean 프로퍼티를 동시에 사용하면 우선순위는 어떻게 될까?</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PostConstruct Init bean  // JSR-250
Init Foo // @Bean의 프로퍼티
cleanup Bar // @Bean의 프로퍼티
PreDestroy bean // JSR-250
</code></pre></div></div>

<p>결과를 보면, JSR-250이 먼저 초기화되고, 그 다음에 <code class="language-plaintext highlighter-rouge">@Bean의 프로퍼티</code>가 그 다음 동작 한다.</p>

<h2 id="맺음말">맺음말</h2>

<ul>
  <li>스프링에서 무심코 사용했던 Bean들에 대해서 알아봤다.</li>
  <li>왜 기본 Bean 스코프가 싱글턴인가? prototype으로 매 요청마다 생겼을 때 어떤 일들이 벌어질까?</li>
  <li>전처리/후처리로 어떤 처리들을 자주,많이 할까?</li>
</ul>
:ET