I")4<h2 id="들어가며">들어가며</h2>

<p>JPA 연관관계 매핑중, 실무에서 가장 많이 쓰이는 1:N (일대다) 매핑에 대해서 알아보자.<br />
일대다 매핑을 하기 위해서 하나의 팀에 여러명의 멤버가 속해있는, 1:N 관계를 생각해보자.<br />
관계 매핑에는 <code class="language-plaintext highlighter-rouge">방향성</code>과 <code class="language-plaintext highlighter-rouge">외래키의 주인</code> 두 가지 상황이 발생 한다.(객체와 테이블간의 패러다임 불일치 때문에)<br />
일반적으로 객체에서는 참조를 통해서 방향성을 갖는다.</p>

<h3 id="객체에서-방향성이란">객체에서 방향성이란?</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>memeber.getTeam() 을 통해서 team을 조회할 수 있다.<br />
즉, member -&gt; team간의 단방향(방향성)을 갖지만, 반대의 방향성은 존재하지 않는다.<br />
만약에 반대 상황도 존재할려면</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">memberList</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이렇게 설정해야지만, team.getMemberList()를 통해서 접근 할 수 있다. 이렇게 객체간의 참조를 통해서 탐색하는 과정을 <code class="language-plaintext highlighter-rouge">객체 그래프 탐색</code>이라고 한다.</p>

<h2 id="외래키의-주인">외래키의 주인?</h2>

<p>@OneToMany에서 mappedBy 속성이 존재한다. 외래키의 주인을 설정하는 속성이다.</p>

<p>외래키의 주인을 왜 설정해야 하나?</p>

<p>Entity의 양방향 매핑은 단방향 매핑2개로 존재한다.</p>
<ul>
  <li>Member -&gt; Team (단방향)</li>
  <li>Team -&gt; Member (단방향)</li>
</ul>

<p>하지만, 엔티티가 아닌 테이블에서는 연관관계는 다음과 같이 한개만 존재한다.</p>
<ul>
  <li>Member &lt;-&gt; Team (양방향)</li>
</ul>

<p>그렇기 때문에 Entity의 관리포인트가 2군데이기 때문에 <strong>연관관계의 주인</strong>을 설정해줘야 한다.</p>

<blockquote>
  <p>연관관계의 주인이면 무엇을 할수 있나? 
연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래키를 관리(등록, 수정, 삭제) 할수 있다. 반면에 주인이 아닌 쪽은 읽기만 할 수 있다.</p>
</blockquote>

<h4 id="연관관계의-주인은-외래키가-있는곳">연관관계의 주인은 외래키가 있는곳!!!!!!!!!</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span><span class="o">=</span><span class="s">"team"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>다음과 같은 상황에서 연관관계의 주인은 mappedBy 속성의 반대에 있는 <code class="language-plaintext highlighter-rouge">Member.team</code> 을 갖는다.</p>

<blockquote>
  <p>데이터베이스 테이블에서 항상 다애일 관계에서 다(Many) 쪽이 외래키를 가진다. 그래서 @ManyToOne에는 mappedBy속성이 존재하지 않고, @OneToMany에만 mappedBy 속성이 존재한다.</p>
</blockquote>

<h1 id="2예제-코드">2.예제 코드</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER"</span><span class="o">)</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">age</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div>

<p>먼저 member -&gt; team 의 단방향 관계를 살펴 보자.
Member(다) : Team(일) 관계를 갖는다. @JoinColumn 은 TEAM_ID를 갖는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Data</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM"</span><span class="o">)</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="c1">// 양방향 관계일 때만 설정함</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">memberList</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Member과 Team간의 연관관계 매핑에서 핵심은</p>

<p><code class="language-plaintext highlighter-rouge">@ManyToOne</code> 과 <code class="language-plaintext highlighter-rouge">@JoinColumn</code> 의 쌍으로 이루어진다. 특히나 JoinColumn은 표시하지 않아도 JPA가 자동으로 해당 필드(team)에 _ID를 붙여서 자동으로 생성해 주지만, 실무에서는 명시적으로 사용하는 것을 권한다.</p>

<p>실제 테스트 케이스를 통해서 검증해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span>
<span class="nd">@Rollback</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberTeamTests</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
    
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">TeamRepository</span> <span class="n">teamRepository</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">();</span>
        <span class="n">team</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"A팀"</span><span class="o">);</span>
        <span class="n">teamRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">team</span><span class="o">);</span> <span class="c1">// team 저장</span>

        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"andrew"</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">32L</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span> <span class="c1">//member의 team setting</span>
        <span class="n">memberRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">//member 저장</span>

        <span class="c1">//when</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">optionalMember</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>

        <span class="c1">//then</span>
        <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="n">optionalMember</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getTeam</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">team</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hibernate: call next value for hibernate_sequence
Hibernate: insert into team (name, id) values (?, ?)
Hibernate: call next value for hibernate_sequence
Hibernate: insert into member (age, name, team_id, id) values (?, ?, ?, ?)
Hibernate: select member0_.id as id1_0_0_, member0_.age as age2_0_0_, member0_.name as name3_0_0_, member0_.team_id as team_id4_0_0_, team1_.id as id1_1_1_, team1_.name as name2_1_1_ from member member0_ left outer join team team1_ on member0_.team_id=team1_.id where member0_.id=?
</code></pre></div></div>

<p>실제 나간 쿼리를 살펴보면, team 테이블에 데이터를 저장하고, member 테이블에 저장하고, 결과를 select해온다. 
기본 <code class="language-plaintext highlighter-rouge">left outer join</code> 키워드가 나간것을 주목하자! 
각각 Team과 Member가 저장되고, member.getTeam()를 통해서 객체 그래프 탐색까지 잘 되는 것을 확인할 수 있습니다.</p>
:ET