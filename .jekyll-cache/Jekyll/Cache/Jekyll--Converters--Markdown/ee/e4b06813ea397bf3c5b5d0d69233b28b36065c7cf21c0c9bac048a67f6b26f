I"<p>Spring Data Jpa에서 제공하는 <code class="language-plaintext highlighter-rouge">JpaRepository</code>의 구현체인 <code class="language-plaintext highlighter-rouge">SimpleJpaReposity</code>의 <code class="language-plaintext highlighter-rouge">@Transactional</code>을 어떻게 사용하는지 살펴보고, 실제 우리 서비스에서 어떻게 적용하면 좋을지에 대해서 생각해보자.</p>

<h2 id="1-jparepository의-구현체인-simplejparepository를-열어보면">1. JpaRepository의 구현체인 SimpleJpaRepository를 열어보면</h2>

<p>JpaRepository의 구현체인 SimpleJpaRepositry를 살펴보면, 클래스 레벨에 <code class="language-plaintext highlighter-rouge">@Transactional(readOnly= ture)</code> 라고 붙어 있다. 모든 메서드는 기본은 <code class="language-plaintext highlighter-rouge">readOnly=ture</code> 로 하고, 변경사항이 있는 메서드들은 추가로 <code class="language-plaintext highlighter-rouge">@Transactional</code> 을 붙였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="c1">// 클래스 레벨은 기본 읽기 옵션으로 설정하고</span>
<span class="nd">@Transactional</span><span class="o">(</span><span class="n">readOnly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleJpaRepository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">JpaRepositoryImplementation</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="o">{</span>


    <span class="c1">// 데이터의 변경사항이 있는 메서드 레벨에는 직접 @Transactional 어노테이션을 붙였다.</span>
    <span class="c1">// default가 readOnly = false 이기 때문에</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="no">T</span> <span class="n">entity</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">entity</span><span class="o">,</span> <span class="s">"The entity must not be null!"</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">em</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">entity</span><span class="o">)</span> <span class="o">?</span> <span class="n">entity</span> <span class="o">:</span> <span class="n">em</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">entity</span><span class="o">));</span>
    <span class="o">}</span>
</code></pre></div></div>

<h2 id="2-readonlytrue-가-의미하는-것은">2. <code class="language-plaintext highlighter-rouge">readOnly=true</code> 가 의미하는 것은?</h2>

<p>즉, 데이터의 변경이 일어나지 않는 조회하는 메서드인 경우에 <code class="language-plaintext highlighter-rouge">@Transactional(readOnly=true)</code> 이렇게 설정한다. 이렇게 설정하면 좋은 점은 Flush모드(데이터 싱크)의 NEVER(필요없음)로 설정하고, Dirty Checking을 하지 않기 때문에 성능이 좋아진다.</p>

<blockquote>
  <p>@Transactional의 readOnly 속성은 현재 Session의 flush모드를 FlushType.MANUAL 로 해서 dirty checking하는 것은 disable 시킨다.</p>
</blockquote>

<h2 id="참고">참고</h2>

<ul>
  <li><a href="https://vladmihalcea.com/spring-read-only-transaction-hibernate-optimization/">Spring read-only transaction Hibernate optimization</a></li>
</ul>
:ET