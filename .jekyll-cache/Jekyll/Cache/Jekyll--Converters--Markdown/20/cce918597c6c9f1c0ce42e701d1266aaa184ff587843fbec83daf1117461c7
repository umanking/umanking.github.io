I"h<h1 id="실무에서-필요한jpa---값타입6">실무에서 필요한JPA - 값타입(6)</h1>

<h2 id="1-들어가며">1. 들어가며</h2>

<ul>
  <li>JPA의 데이터 타입은 <code class="language-plaintext highlighter-rouge">엔티티 타입</code>과 <code class="language-plaintext highlighter-rouge">값 타입</code> 으로 나눌 수 있다.</li>
  <li>값 타입은 다음 3가지로 나눌 수 있다.
    <ul>
      <li>기본값 타입
        <ul>
          <li>자바 기본 타입</li>
          <li>래퍼 클래스</li>
          <li>String</li>
        </ul>
      </li>
      <li>임베디드 타입</li>
      <li>컬렉션 값 타입</li>
    </ul>
  </li>
</ul>

<h2 id="2-기본값-타입">2. 기본값 타입</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@Id</span> <span class="nd">@GenetratedValue</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>  <span class="c1">// 기본 값타입</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>   <span class="c1">// 기본 값타입</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="3-임베디드-타입">3. 임베디드 타입</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  <span class="nd">@Id</span> <span class="nd">@GenetratedValue</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>  <span class="c1">// 기본 값타입</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>   <span class="c1">// 기본 값타입</span>
  
  <span class="nd">@Embedded</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span> 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>임베디드 타입을 사용하려면 2가지 어노테이션이 필요하다.
    <ul>
      <li>@Embeddable: 값 타입을 정의하는 곳에 표시</li>
      <li>@Embedded: 값 타입을 사용하는 곳에 표시</li>
    </ul>
  </li>
  <li>임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다.</li>
  <li>잘 설계한 ORM 애플리케이션은 테이블 수보다 클래스 구가 더 많다.</li>
  <li>@AttributeOverride: 속성 재정의
    <ul>
      <li>임베디드 타입에 정의한 매핑 정보를 재정의 하려면 엔티티에 @AttributeOverride를 사용하면 된다.</li>
    </ul>
  </li>
  <li>임베디드 타입이 null이면 매핑한 컬럼값은 모두 null이다.</li>
</ul>

<h2 id="4-값-타입과-불변객체">4. 값 타입과 불변객체</h2>

<ul>
  <li>값 타입을 여러 엔티티에 공유하면 위험하다.  공유 참조를 하게 되면, 값이 같이 변하게된다.</li>
  <li>해결하기 위해서는 값을 복사해서 사용해야 한다. (clone() 메서드를 이용)</li>
  <li>불변 객체를 구현하는 가장 간단한 방법
    <ul>
      <li>setter를 만들지 않고, 생성자로만 만든다.</li>
    </ul>
  </li>
</ul>

<h2 id="5-값-타입-컬렉션">5. 값 타입 컬렉션</h2>

<ul>
  <li>값 타입 하나 이상 저장하려면 컬렉션에 보관한다.  다음 어노테이션을 사용한다.
    <ul>
      <li>@ElementCollection</li>
      <li>@CollectionTable</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
  
  <span class="nd">@ElementCollection</span>
  <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="s">"FAVORITE_FOODS"</span><span class="o">,</span> 
                  <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER_ID"</span><span class="o">))</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FOOD_NAME"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">favoriteFoods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>테이블에는 컬렉션을 저장할 방법이 없기 때문에, MEMBER 테이블과 FAVORITE_FOOD 테이블로 만들었다.</li>
  <li>값 타입 컬렉션을 사용할때, 부모 엔티티만 저장하면, JPA가 나머지도 실행해준다.</li>
  <li>값 타입 컬렉션은 영속성 전이 + 고아 객체 제거 기능을 필수로 가진다.</li>
  <li>값 타입의 컬렉션 제약사항
    <ul>
      <li>특정 엔티티 하나에 소속된 값 타입 컬렉션이 변경 되었을 때, 매핑된 테이블의 연관된 모든 데이터를 삭제하고, 현재 값 타입 컬렉션 객체에 있는 모든 값을 데이터베이스 다시 저장한다.</li>
      <li>따라서 실무에서 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신에 일대다 관계를 고려해야 한다.</li>
    </ul>
  </li>
</ul>

<h2 id="6-정리">6. 정리</h2>

<ul>
  <li>JPA는 <code class="language-plaintext highlighter-rouge">엔티티 타입</code>과 <code class="language-plaintext highlighter-rouge">값 타입</code>이 있다.</li>
  <li>엔티티 타입
    <ul>
      <li>식별자 @Id가 있다.</li>
      <li>생명주기가 있다.</li>
      <li>공유할 수 있다.
        <ul>
          <li>참조 값을 공유할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>값 타입
    <ul>
      <li>식별자가 없다.</li>
      <li>생명주기를 엔티티에 의존한다.</li>
      <li>공유하지 않는것이 안전하다.
        <ul>
          <li>불변객체로 만드는것이 안전하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

:ET